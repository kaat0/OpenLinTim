#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__all__ =  [
        "EANGenerator",
        "IncrementalSlackEANGenerator",
        "IncreasingSlackEANGenerator",
        "GiveTheRichEANGenerator",
        "GiveTheRichWeightedEANGenerator",
    ]

import operator

from robtim import Dataset, LinTimCSVWriter

class EANGenerator:
    """
    Abstract super class of all EANGenerators.
    An EANGenerator generates EANs with the objective of optimizing their robustness.
    """
    def initialize(self, dataset : Dataset) -> None:
        """
        Initialize the EANGenerator. This is where the configuration of LinTim components
        should take place.
        
        :param dataset: Dataset which the EANs are generated for
        """
        pass
    def eans(self, dataset : Dataset):
        """
        Python generator for EANs. This function must for every iteration write 
        an EAN into the respective files in the dataset and yield a dict with the following information:
            
        - `activitiesModified`: the number of modified activities
        - `activitiesModifiedWeighted`: the number of modified activities weighted by the amount passengers on the activity
        - `slackAdded`: the number of minutes added to the lower bounds of the activities
        - `slackAddedWeighted`: the number of minutes added to the lower bounds of the activities weighted by the amount of passengers on the activity
        
        Implementations of this function must ensure this exact order. All values are
        relative to the dataset's EAN at the point this function is called.
        
        Note that in contrary to the :class:`robtim.eval.ScenarioGenerator` an EANGenerator
        must not take care of the termination of the optimization. This function 
        can or cannot yield infinitely many EANs. The interruption of the process
        is done by the :class:`Supervisor`.
        
        :param dataset: Dataset which the EANs are generated for
        
        """
        pass

class IncrementalSlackEANGenerator(EANGenerator):
    """
    EANGenerator which increased the slack time incrementally by calling its function
    distribute in every loop for every activity. 
    
    The behaviour of the generator depends on the implementation of :func:`distribute`
    which must be overwritten by inheriting classes. In every iteration and for every
    activity this function is called to determine the new lower and upper bounds.
    
    """
    def eans(self, dataset : Dataset):
        eanInfo = {
                    "activitiesModified" : 0,
                    "activitiesModifiedWeighted" : 0,
                    "slackAdded" : 0,
                    "slackAddedWeighted" : 0,
                }
        
        yield eanInfo
        
        while True:
            eanInfo = dict(eanInfo)
            new_activities = dataset.readCSV("timetabling/Activities-periodic.giv")
            hasMore = False
            
            with open(dataset.realPath("timetabling/Activities-periodic.giv"), "wt") as f:
                w = LinTimCSVWriter(f)
                w.write("# EAN generated by RobustTimetabling")
                w.write("# activity_index; type; from_event; to_event; lower_bound; upper_bound; passengers")
                                
                for new_activity in new_activities:
                    lb, ub = self.distribute(dataset, *new_activity)
                    if int(lb) != int(new_activity[4]) or int(ub) != int(new_activity[5]):
                        hasMore = True
                        eanInfo["activitiesModified"] += 1
                        eanInfo["activitiesModifiedWeighted"] += int(new_activity[6])
                        eanInfo["slackAdded"] += int(lb) - int(new_activity[4])
                        eanInfo["slackAddedWeighted"] += (int(lb) - int(new_activity[4])) * int(new_activity[6])
                    new_activity[4] = lb
                    new_activity[5] = ub
                    w.write(new_activity)
            yield eanInfo
            if not hasMore:
                return
    def distribute(self, 
                   dataset : Dataset, 
                   activity_index : int, activity_type : str, from_event : int, 
                   to_event : int, lower_bound : int, upper_bound : int, 
                   passengers : int):
        """
        Decides how much slack an activity receives. This function is called in
        every iteration and for every activitiy.
        
        :param dataset: dataset which the optimization is done on
        :param activity_index: index of the activity in the respective file
        :param activity_type: type of the activity, e.g. `drive`, `wait` etc.
        :param from_event: id of the starting event
        :param to_event: id of the end event
        :param lower_bound: current lower bound
        :param upper_bound: current upper bound
        :param passengers: amount of passengers on the activitiy
        :return: tuple (lower_bound, upper_bound) with the new bounds
        """
        return lower_bound, upper_bound
    
class IncreasingSlackEANGenerator(IncrementalSlackEANGenerator):
    """
    EANGenerator which increases the slack of all activities by a given number of minutes (step).
    If increaseUpperBounds == False, the generator will stop making changes after
    the upper bounds are reached. Otherwise it will increase lower and upper bounds
    simultaneously. 
    
    :param step: minutes of slack which should be added to the lower bounds in every loop.
    :param increaseUpperBounds: whether upper bound should be increased as well.
    :param activitiyTypes: list of activities, e.g. "drive", "wait", or None if 
        all types of activities should be affected
    """
    def __init__(self, step : int, increaseUpperBounds : bool = False, activitiyTypes : list = None):
        self.step = step
        self.increaseUpperBounds = increaseUpperBounds
        self.activityTypes = activitiyTypes
    def distribute(self, 
                   dataset : Dataset, 
                   activity_index : int, activity_type : str, from_event : int, to_event : int, lower_bound : int, upper_bound : int, passengers : int):
        if passengers == 0 or (self.activityTypes is not None and not(activity_type in self.activityTypes)):
            return lower_bound, upper_bound
        lower_bound += self.step
        if self.increaseUpperBounds:
           upper_bound += self.step
        elif lower_bound > upper_bound:
            lower_bound = upper_bound
        return lower_bound, upper_bound

class GiveTheRichEANGenerator(EANGenerator):
    """
    EANGenerator which instead of increasing the slack re-distributes it in every
    iteration. The total amount of slack which is added to the EAN ist kept constant.
    The following procedure is used:
        
    - sort all activities by their number of passengers in reverse order
    - iterate n = number of non-zero activities to 0 with given step:
        - add slack time to the first n most important activities 
        - the amount of slack which an activity receives equals its ratio
          of the number of passengers
    
    In addition to the EAN properties which are defined by :class:`EANGenerator`
    this generator yields the following information
    
    - `ratioRich`: ratio of the non-zero activities which are considered rich, i.e.
      which received slack, value in [0,1]
    
    :param totalSlack: total amount of slack which is then redistributed (in min)
    :param step: step which the amount of rich activities is reduced by in every iteration
    :param stepAbsolute: whether the step is an absolute number, if not the absolute step is computed
        by (number of non-zero acitivities)*step//100
    :param activityTypes: list of acitivity types, e.g. `drive`, `wait` etc. which 
        may receive slack, default: `drive` and `wait`.
    """
    def __init__(self, totalSlack : int, step : int = 1, stepAbsolute : bool = True, activitiyTypes : list = ["drive", "wait"]):
        self.totalSlack = totalSlack
        self.step = step
        self.stepAbsolute = stepAbsolute
        self.activityTypes = activitiyTypes
    def eans(self, dataset : Dataset):
        eanInfo = {
                    "activitiesModified" : 0,
                    "activitiesModifiedWeighted" : 0,
                    "slackAdded" : 0,
                    "slackAddedWeighted" : 0,
                    "ratioRich": 1
                }
        
        yield eanInfo
        
        activities = dataset.readCSV("timetabling/Activities-periodic.giv")
        
        non_zero_activities = list(filter(lambda row : row[6] > 0 and (row[1] in self.activityTypes), activities))
        zero_activities     = list(filter(lambda row : row[6] == 0 or not(row[1] in self.activityTypes), activities))
        
        non_zero_activities = sorted(non_zero_activities, key=operator.itemgetter(6), reverse=True)
        
        if not self.stepAbsolute:
            self.step = len(non_zero_activities) * self.step // 100
            
        assert (self.step >= 0), "step invalid, must be at least 1"
        
        for rich in range(len(non_zero_activities) - self.step, 0, - self.step):
            totalPassengers = sum((row[6] for row in non_zero_activities[:rich]))
            totalSlack = self.totalSlack
            
            eanInfo = {
                    "activitiesModified" : 0,
                    "activitiesModifiedWeighted" : 0,
                    "slackAdded" : 0,
                    "slackAddedWeighted" : 0,
                    "ratioRich": rich / len(non_zero_activities)                    
                }
            
            with open(dataset.realPath("timetabling/Activities-periodic.giv"), "wt") as f:
                w = LinTimCSVWriter(f)
                w.write("# EAN generated by RobustTimetabling")
                w.write("# activity_index; type; from_event; to_event; lower_bound; upper_bound; passengers")
                new_activities = []
                
                for activity in list(non_zero_activities[:rich]):
                    slack = round(totalSlack * activity[6] / totalPassengers)
                    totalSlack -= slack
                    totalPassengers -= activity[6]
                    activity[4] += slack
                    activity[5] += slack
                    
                    eanInfo["activitiesModified"] += 1
                    eanInfo["activitiesModifiedWeighted"] += activity[6]
                    eanInfo["slackAdded"] += slack
                    eanInfo["slackAddedWeighted"] += slack * activity[6]
                    
                    new_activities.append(activity)
                
                # Sort the activities again by ID. ro-rollout would otherwise fail
                new_activities = list(new_activities + non_zero_activities[rich:] + zero_activities)
                new_activities = sorted(new_activities, key=operator.itemgetter(0))
                for activity in new_activities:
                    w.write(activity)
            yield eanInfo
                        
class GiveTheRichWeightedEANGenerator(EANGenerator):
    """
    EANGenerator which instead of increasing the slack re-distributes it in every
    iteration. The *weighted* total amount of slack which is added to the EAN ist kept constant.
    The following procedure is used:
        
    - sort all activities by their number of passengers in reverse order
    - iterate n = number of non-zero activities to 0 with given step:
        - add slack time to the first n most important activities 
        - the amount of slack which an activity receives equals its ratio
          of the number of passengers
    
    In addition to the EAN properties which are defined by :class:`EANGenerator`
    this generator yields the following information
    
    - `ratioRich`: ratio of the non-zero activities which are considered rich, i.e.
      which received slack, value in [0,1]
    - `slackPerPassenger`: slack which an activitiy got for one passenger
    
    :param totalSlack: total amount of slack which is then redistributed (in min)
    :param step: step which the amount of rich activities is reduced by in every iteration
    :param stepAbsolute: whether the step is an absolute number, if not the absolute step is computed
        by (number of non-zero acitivities)*step//100
    :param activityTypes: list of acitivity types, e.g. `drive`, `wait` etc. which 
        may receive slack, default: `drive` and `wait`.        
    """
    def __init__(self, initalSlackPerPassenger : float, step : int = 1, stepAbsolute : bool = True, activitiyTypes : list = ["drive", "wait"]):
        self.initalSlackPerPassenger = initalSlackPerPassenger
        self.step = step
        self.stepAbsolute = stepAbsolute
        self.activityTypes = activitiyTypes
    def eans(self, dataset : Dataset):
        eanInfo = {
                    "activitiesModified" : 0,
                    "activitiesModifiedWeighted" : 0,
                    "slackAdded" : 0,
                    "slackAddedWeighted" : 0,
                    "ratioRich": 1,
                    "slackPerPassenger": self.initalSlackPerPassenger,
                }
        
        yield eanInfo
        
        activities = dataset.readCSV("timetabling/Activities-periodic.giv")
        
        non_zero_activities = list(filter(lambda row : row[6] > 0 and row[1] in self.activityTypes, activities))
        zero_activities     = list(filter(lambda row : row[6] == 0 or not (row[1] in self.activityTypes), activities))
        
        non_zero_activities = sorted(non_zero_activities, key=operator.itemgetter(6), reverse=True)
        
        initialTotalPassengers2 = sum((row[6]**2 for row in non_zero_activities))
        
        if not self.stepAbsolute:
            self.step = len(non_zero_activities) * self.step // 100
        
        for rich in range(len(non_zero_activities) - self.step, 0, - self.step):
            totalPassengers2 = sum((row[6]**2 for row in non_zero_activities[:rich]))
            slackPerPassenger = self.initalSlackPerPassenger * initialTotalPassengers2 / totalPassengers2
            
            eanInfo = {
                    "activitiesModified" : 0,
                    "activitiesModifiedWeighted" : 0,
                    "slackAdded" : 0,
                    "slackAddedWeighted" : 0,
                    "ratioRich": rich / len(non_zero_activities),
                    "slackPerPassenger": slackPerPassenger,
                }
            
            with open(dataset.realPath("timetabling/Activities-periodic.giv"), "wt") as f:
                w = LinTimCSVWriter(f)
                w.write("# EAN generated by RobustTimetabling")
                w.write("# activity_index; type; from_event; to_event; lower_bound; upper_bound; passengers")
                
                new_activities = []
                
                for activity in list(non_zero_activities[:rich]):
                    slack = round(slackPerPassenger * activity[6])
                    activity[4] += slack
                    activity[5] += slack
                    
                    eanInfo["activitiesModified"] += 1
                    eanInfo["activitiesModifiedWeighted"] += activity[6]
                    eanInfo["slackAdded"] += slack
                    eanInfo["slackAddedWeighted"] += slack * activity[6]
                    
                    new_activities.append(activity)
                
                # Sort the activities again by ID. ro-rollout would otherwise fail
                new_activities = list(new_activities + non_zero_activities[rich:] + zero_activities)
                new_activities = sorted(new_activities, key=operator.itemgetter(0))
                for activity in new_activities:
                    w.write(activity)
            yield eanInfo
                        
